#define __STDC_FORMAT_MACROS

#include <stdio.h>
#include <fcntl.h>

#include <sinsp.h>
#include "source_plugin.h"

#ifdef _WIN32
#include <io.h>
#else
#include <unistd.h>
#include <getopt.h>
#endif

#define READ_FROM_FILE
#define READ_FROM_FILE_FNAME "dmesg.txt"
#define READ_FROM_KERNEL_FNAME "/dev/kmsg"
#define DATABUF_SIZE (4096 * 4)

typedef struct kmsg_plugin_state
{
	char databuf[DATABUF_SIZE];
}kmsg_plugin_state;

src_plugin_t* kmsginit(char* config, int32_t* rc)
{
	*rc = SCAP_SUCCESS;

	kmsg_plugin_state* s = (kmsg_plugin_state*)malloc(sizeof(kmsg_plugin_state));
	if(s == NULL)
	{
		*rc = SCAP_FAILURE;
	}

	return s;
}

char* kmsgget_last_error()
{
	return (char*)"kmsg plugin failure";
}

void kmsgdestroy(src_plugin_t* s)
{
	if(s)
	{
		free(s);
	}
}

uint32_t kmsgget_id()
{
	return 1;
}

char* kmsgget_name()
{
	return (char*)"kmsg";
}

char* kmsgget_description()
{
	return (char*)"capture kernel information messages generated by /dev/kmsg and that linux users typically display with dmesg.";
}

char* kmsgget_fields()
{
	return (char*)
		"["
		"{\"type\": \"integer\", \"name\": \"kmsg.severity\", \"desc\":\"the message syslog-style severity, as a number between 0 (emergency) and 7 (debug).\"},"
		"{\"type\": \"string\", \"name\": \"kmsg.full_line\", \"desc\":\"the full message line.\"},"
		"{\"type\": \"integer\", \"name\": \"kmsg.seq_num\", \"desc\":\"the message's incremental sequence number assigned by the kernel.\"},"
		"{\"type\": \"string\", \"name\": \"kmsg.str\", \"desc\":\"the humar readable part of the message.\"},"
		"{\"type\": \"string\", \"name\": \"kmsg.source\", \"desc\":\"the component that generated the message, defined as the text before the last ':' in the human readable part of the message.\"}"
		"]"
		;
}

src_instance_t* kmsgopen(src_plugin_t* s, int32_t* rc)
{
	*rc = SCAP_SUCCESS;

#ifdef READ_FROM_FILE
	FILE* f = fopen(READ_FROM_FILE_FNAME, "r");
	if(f == NULL)
	{
		*rc = SCAP_FAILURE;
	}

	return (src_instance_t*)f;
#else
	int fd = open(READ_FROM_KERNEL_FNAME, _O_BINARY | _O_RDONLY);
	if(fd < 0)
	{
		snprintf(error, SCAP_LASTERR_SIZE, "dmesg plugin open error: cannot open %s", READ_FROM_KERNEL_FNAME);
		*rc = SCAP_FAILURE;
	}

	return (src_instance_t*)(uint64_t)fd;
#endif
}

void kmsgclose(src_plugin_t* s, src_instance_t* h)
{
	if(h != NULL)
	{
#ifdef READ_FROM_FILE
		fclose((FILE*)h);
#else
		close((int)(int64_t)h);
#endif
	}
}

int32_t kmsgnext(src_plugin_t* s, src_instance_t* h, uint8_t** data, uint32_t* datalen)
{
	kmsg_plugin_state* ts = (kmsg_plugin_state*)s;
	int rres;

#ifdef READ_FROM_FILE
	if(fgets(ts->databuf, DATABUF_SIZE, (FILE*)h) != NULL)
	{
		rres = strlen(ts->databuf);
	}
	else
	{
#ifdef _WIN32		
		Sleep(1000);
#else
		sleep(1);
#endif
		return SCAP_TIMEOUT;
	}
#else
	int rres = read((int)(int64_t)h, ts->databuf, DATABUF_SIZE);
	if(rres <= 0)
	{
		sleep(1);
		return SCAP_TIMEOUT;
	}

	printf("%d) %s\n", rres, ts->databuf);
	exit(0);
#endif
	*data = (uint8_t*)ts->databuf;
	*datalen = rres;

	string sline((char*)*data);
	std::vector<std::string> parts = sinsp_split(sline, ':');
	if(parts.size() < 2)
	{
		// We don't understand this line. Just skip it.
		return SCAP_TIMEOUT;
	}

	string machine_part = parts[0];
	std::vector<std::string> machine_components = sinsp_split(machine_part, ',');

	return SCAP_SUCCESS;
}

char* kmsgevent_to_string(uint8_t* data, uint32_t datalen)
{
	return (char*)"dete";
}

char* kmsgextract_as_string(uint64_t evtnum, uint32_t id, char* arg, uint8_t* data, uint32_t datalen)
{
	return (char*)"estratto stringatto";
}

source_plugin_info create_kmsg_source()
{
	source_plugin_info si =
	{
		.init = kmsginit,
		.get_last_error = kmsgget_last_error,
		.destroy = kmsgdestroy,
		.get_id = kmsgget_id,
		.get_name = kmsgget_name,
		.get_description = kmsgget_description,
		.get_fields = kmsgget_fields,
		.open = kmsgopen,
		.close = kmsgclose,
		.next = kmsgnext,
		.event_to_string = kmsgevent_to_string,
		.extract_as_string = kmsgextract_as_string
	};

	return si;
}
