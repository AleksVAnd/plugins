#define __STDC_FORMAT_MACROS

#include <stdio.h>
#include <fcntl.h>

#include <sinsp.h>
#include "source_plugin.h"

#ifdef _WIN32
#include <io.h>
#else
#include <unistd.h>
#include <getopt.h>
#endif

#define DATABUF_SIZE 4096

typedef struct kmsg_plugin_state
{
	char databuf[DATABUF_SIZE];
}kmsg_plugin_state;

src_plugin_t* kmsginit(char* config, char *error, int32_t* rc)
{
	*rc = SCAP_SUCCESS;

	kmsg_plugin_state* s = (kmsg_plugin_state*)malloc(sizeof(kmsg_plugin_state));
	if(s == NULL)
	{
		snprintf(error, SCAP_LASTERR_SIZE, "plugin state allocation failure");
		*rc = SCAP_FAILURE;
	}

	return s;
}

void kmsgdestroy(src_plugin_t* s)
{
	if(s)
	{
		free(s);
	}
}

uint32_t kmsgget_id()
{
	return 1;
}

char* kmsgget_name()
{
	return (char*)"kmsg";
}

char* kmsgget_description()
{
	return (char*)"capture kernel information messages generated by /dev/kmsg and that linux users typically display with dmesg.";
}

char* kmsgget_fields()
{
	return (char*)
		"["
		"{\"type\": \"integer\", \"name\": \"kmsg.severity\", \"desc\":\"the message syslog-style severity, as a number between 0 (emergency) and 7 (debug).\"},"
		"{\"type\": \"string\", \"name\": \"kmsg.full_line\", \"desc\":\"the full message line.\"},"
		"{\"type\": \"integer\", \"name\": \"kmsg.seq_num\", \"desc\":\"the message's incremental sequence number assigned by the kernel.\"},"
		"{\"type\": \"string\", \"name\": \"kmsg.str\", \"desc\":\"the humar readable part of the message.\"},"
		"{\"type\": \"string\", \"name\": \"kmsg.source\", \"desc\":\"the component that generated the message, defined as the text before the last ':' in the human readable part of the message.\"}"
		"]"
		;
}

#define DMESG_FILE_NAME "dmesg.txt"

src_instance_t* kmsgopen(src_plugin_t* s, char *error, int32_t* rc)
{
	*rc = SCAP_SUCCESS;

	int fd = _open(DMESG_FILE_NAME, _O_BINARY | _O_RDONLY);
	if(fd < 0)
	{
		snprintf(error, SCAP_LASTERR_SIZE, "dmesg plugin open error: cannot open %s", DMESG_FILE_NAME);
		*rc = SCAP_FAILURE;
	}

	return (src_instance_t*)(uint64_t)fd;
}

void kmsgclose(src_plugin_t* s, src_instance_t* h)
{
	if(h != NULL)
	{
		_close((int)(int64_t)h);
	}
}

int32_t kmsgnext(src_plugin_t* s, src_instance_t* h, uint8_t** data, uint32_t* datalen)
{
//	(*pevent)->type = PPME_SYSCALL_OPEN_E;
	kmsg_plugin_state* ts = (kmsg_plugin_state*)s;
	
	int rres = _read((int)(int64_t)h, ts->databuf, DATABUF_SIZE);
	if(rres <= 0)
	{
		Sleep(1000);
		return SCAP_TIMEOUT;
	}

	*data = (uint8_t*)ts->databuf;
	*datalen = rres;
printf("%s\n", *data);
	return SCAP_SUCCESS;
}

char* kmsgevent_to_string(uint8_t* data, uint32_t datalen)
{
	return (char*)"dete";
}

char* kmsgextract_as_string(uint32_t id, uint8_t* data, uint32_t datalen)
{
	return (char*)"estratto stringatto";
}

source_plugin_info create_kmsg_source()
{
	source_plugin_info si =
	{
		.open = kmsgopen,
		.close = kmsgclose,
		.next = kmsgnext,
		.init = kmsginit,
		.destroy = kmsgdestroy,
		.get_id = kmsgget_id,
		.get_name = kmsgget_name,
		.get_description = kmsgget_description,
		.get_fields = kmsgget_fields,
		.event_to_string = kmsgevent_to_string,
		.extract_as_string = kmsgextract_as_string
	};

	return si;
}
